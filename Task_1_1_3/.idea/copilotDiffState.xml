<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/ru/nsu/dashkovskii/Parser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/ru/nsu/dashkovskii/Parser.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Класс для пар��инга математических выражений из строки.&#10; */&#10;public class Parser {&#10;    private String string;&#10;&#10;    /**&#10;     * Парсит математическое выражение из строки.&#10;     *&#10;     * @param s строка с выражением&#10;     * @return объект Expression, представляющий выражение&#10;     * @throws IllegalArgumentException если выражение некорректно&#10;     */&#10;    public static Expression parse(String s) {&#10;        s = s.trim();&#10;&#10;        if (s.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Пустое выражение&quot;);&#10;        }&#10;&#10;        if (!isValidParentheses(s)) {&#10;            throw new IllegalArgumentException(&quot;Некорректная расстановка скобок&quot;);&#10;        }&#10;&#10;        return parseExpression(s);&#10;    }&#10;&#10;    /**&#10;     * Парсит выражение с учетом приоритета операций.&#10;     */&#10;    private static Expression parseExpression(String s) {&#10;        s = s.trim();&#10;&#10;        while (s.startsWith(&quot;(&quot;) &amp;&amp; s.endsWith(&quot;)&quot;) &amp;&amp; isMatchingParentheses(s, 0, s.length() - 1)) {&#10;            s = s.substring(1, s.length() - 1).trim();&#10;        }&#10;&#10;        int operatorPos = findOperator(s, new char[]{'+', '-'});&#10;        if (operatorPos != -1) {&#10;            char operator = s.charAt(operatorPos);&#10;            String leftStr = s.substring(0, operatorPos).trim();&#10;            String rightStr = s.substring(operatorPos + 1).trim();&#10;&#10;            if (leftStr.isEmpty() || rightStr.isEmpty()) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Отсутствует операнд рядом с оператором '&quot; + operator + &quot;'&quot;);&#10;            }&#10;&#10;            Expression left = parseExpression(leftStr);&#10;            Expression right = parseExpression(rightStr);&#10;&#10;            return operator == '+' ? new Add(left, right) : new Sub(left, right);&#10;        }&#10;&#10;        operatorPos = findOperator(s, new char[]{'*', '/'});&#10;        if (operatorPos != -1) {&#10;            char operator = s.charAt(operatorPos);&#10;            String leftStr = s.substring(0, operatorPos).trim();&#10;            String rightStr = s.substring(operatorPos + 1).trim();&#10;&#10;            if (leftStr.isEmpty() || rightStr.isEmpty()) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Отсутствует операнд рядом с оператором '&quot; + operator + &quot;'&quot;);&#10;            }&#10;&#10;            Expression left = parseExpression(leftStr);&#10;            Expression right = parseExpression(rightStr);&#10;&#10;            return operator == '*' ? new Mul(left, right) : new Div(left, right);&#10;        }&#10;&#10;        if (isValidVariable(s)) {&#10;            return new Variable(s);&#10;        }&#10;&#10;        try {&#10;            return new Number(Integer.parseInt(s));&#10;        } catch (NumberFormatException e) {&#10;            throw new IllegalArgumentException(&quot;Некорректное число: '&quot; + s + &quot;'&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Находит позицию оператора с наименьшим приоритетом, не находящегося в скобках.&#10;     */&#10;    private static int findOperator(String s, char[] operators) {&#10;        int depth = 0;&#10;&#10;        for (int i = s.length() - 1; i &gt;= 0; i--) {&#10;            char c = s.charAt(i);&#10;            if (c == ')') {&#10;                depth++;&#10;            } else if (c == '(') {&#10;                depth--;&#10;            } else if (depth == 0) {&#10;                for (char op : operators) {&#10;                    if (c == op) {&#10;                        return i;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return -1;&#10;    }&#10;&#10;    /**&#10;     * Проверяет, соответствуют ли скобки на позициях start и end.&#10;     */&#10;    private static boolean isMatchingParentheses(String s, int start, int end) {&#10;        if (s.charAt(start) != '(' || s.charAt(end) != ')') {&#10;            return false;&#10;        }&#10;&#10;        int depth = 0;&#10;        for (int i = start; i &lt;= end; i++) {&#10;            if (s.charAt(i) == '(') {&#10;                depth++;&#10;            } else if (s.charAt(i) == ')') {&#10;                depth--;&#10;                if (depth == 0 &amp;&amp; i &lt; end) {&#10;                    return false;&#10;                }&#10;            }&#10;        }&#10;&#10;        return depth == 0;&#10;    }&#10;&#10;    /**&#10;     * Проверяет корректность расстановки скобок в строке.&#10;     *&#10;     * @param s строка для проверки&#10;     * @return true, если скобки расставлены корректно&#10;     */&#10;    private static boolean isValidParentheses(String s) {&#10;        int count = 0;&#10;        for (char c : s.toCharArray()) {&#10;            if (c == '(') {&#10;                count++;&#10;            }&#10;            if (c == ')') {&#10;                count--;&#10;            }&#10;            if (count &lt; 0) {&#10;                return false;&#10;            }&#10;        }&#10;        return count == 0;&#10;    }&#10;&#10;    private static boolean isValidVariable(String s) {&#10;        if (s.isEmpty()) {&#10;            return false;&#10;        }&#10;        if (!Character.isLetter(s.charAt(0))) {&#10;            return false;&#10;        }&#10;        for (char c : s.toCharArray()) {&#10;            if (!Character.isLetterOrDigit(c)) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Парсит строку с присваиваниями переменных.&#10;     *&#10;     * @param assignments строка вида &quot;x = 10; y = 13&quot;&#10;     * @return карта переменных и их значений&#10;     * @throws IllegalArgumentException если формат присваиваний некорректен&#10;     */&#10;    public static Map&lt;String, Integer&gt; parseAssignments(String assignments) {&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;&#10;        if (assignments == null || assignments.trim().isEmpty()) {&#10;            return vars;&#10;        }&#10;&#10;        String[] pairs = assignments.split(&quot;;&quot;);&#10;        for (String pair : pairs) {&#10;            pair = pair.trim();&#10;            if (pair.isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            String[] kv = pair.split(&quot;=&quot;);&#10;            if (kv.length != 2) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректный формат присваивания: '&quot; + pair&#10;                        + &quot;'. Ожидается формат 'переменная = значение'&quot;);&#10;            }&#10;&#10;            String varName = kv[0].trim();&#10;            String valueStr = kv[1].trim();&#10;&#10;            if (!isValidVariable(varName)) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректное имя переменной: '&quot; + varName&#10;                        + &quot;'. Переменная должна начинаться с буквы и содержать только &quot;&#10;                        + &quot;буквы и цифры&quot;);&#10;            }&#10;&#10;            try {&#10;                int value = Integer.parseInt(valueStr);&#10;                vars.put(varName, value);&#10;            } catch (NumberFormatException e) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректное значение переменной: '&quot; + valueStr&#10;                        + &quot;'. Ожидается целое число&quot;);&#10;            }&#10;        }&#10;&#10;        return vars;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Класс для пар��инга математических выражений из строки.&#10; */&#10;public class Parser {&#10;    private String string;&#10;&#10;    /**&#10;     * Парсит математическое выражение из строки.&#10;     *&#10;     * @param s строка с выражением&#10;     * @return объект Expression, представляющий выражение&#10;     * @throws IllegalArgumentException если выражение некорректно&#10;     */&#10;    public static Expression parse(String s) {&#10;        s = s.trim();&#10;&#10;        if (s.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Пустое выражение&quot;);&#10;        }&#10;&#10;        if (!isValidParentheses(s)) {&#10;            throw new IllegalArgumentException(&quot;Некорректная расстановка скобок&quot;);&#10;        }&#10;&#10;        return parseExpression(s);&#10;    }&#10;&#10;    /**&#10;     * Парсит выражение с учетом приоритета операций.&#10;     */&#10;    private static Expression parseExpression(String s) {&#10;        s = s.trim();&#10;&#10;        while (s.startsWith(&quot;(&quot;) &amp;&amp; s.endsWith(&quot;)&quot;) &amp;&amp; isMatchingParentheses(s, 0, s.length() - 1)) {&#10;            s = s.substring(1, s.length() - 1).trim();&#10;        }&#10;&#10;        int operatorPos = findOperator(s, new char[]{'+', '-'});&#10;        if (operatorPos != -1) {&#10;            char operator = s.charAt(operatorPos);&#10;            String leftStr = s.substring(0, operatorPos).trim();&#10;            String rightStr = s.substring(operatorPos + 1).trim();&#10;&#10;            if (leftStr.isEmpty() || rightStr.isEmpty()) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Отсутствует операнд рядом с оператором '&quot; + operator + &quot;'&quot;);&#10;            }&#10;&#10;            Expression left = parseExpression(leftStr);&#10;            Expression right = parseExpression(rightStr);&#10;&#10;            return operator == '+' ? new Add(left, right) : new Sub(left, right);&#10;        }&#10;&#10;        operatorPos = findOperator(s, new char[]{'*', '/'});&#10;        if (operatorPos != -1) {&#10;            char operator = s.charAt(operatorPos);&#10;            String leftStr = s.substring(0, operatorPos).trim();&#10;            String rightStr = s.substring(operatorPos + 1).trim();&#10;&#10;            if (leftStr.isEmpty() || rightStr.isEmpty()) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Отсутствует операнд рядом с оператором '&quot; + operator + &quot;'&quot;);&#10;            }&#10;&#10;            Expression left = parseExpression(leftStr);&#10;            Expression right = parseExpression(rightStr);&#10;&#10;            return operator == '*' ? new Mul(left, right) : new Div(left, right);&#10;        }&#10;&#10;        if (isValidVariable(s)) {&#10;            return new Variable(s);&#10;        }&#10;&#10;        try {&#10;            return new Number(Integer.parseInt(s));&#10;        } catch (NumberFormatException e) {&#10;            throw new IllegalArgumentException(&quot;Некорректное число: '&quot; + s + &quot;'&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Находит позицию оператора с наименьшим приоритетом, не находящегося в скобках.&#10;     */&#10;    private static int findOperator(String s, char[] operators) {&#10;        int depth = 0;&#10;&#10;        for (int i = s.length() - 1; i &gt;= 0; i--) {&#10;            char c = s.charAt(i);&#10;            if (c == ')') {&#10;                depth++;&#10;            } else if (c == '(') {&#10;                depth--;&#10;            } else if (depth == 0) {&#10;                for (char op : operators) {&#10;                    if (c == op) {&#10;                        return i;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return -1;&#10;    }&#10;&#10;    /**&#10;     * Проверяет, соответствуют ли скобки на позициях start и end.&#10;     */&#10;    private static boolean isMatchingParentheses(String s, int start, int end) {&#10;        if (s.charAt(start) != '(' || s.charAt(end) != ')') {&#10;            return false;&#10;        }&#10;&#10;        int depth = 0;&#10;        for (int i = start; i &lt;= end; i++) {&#10;            if (s.charAt(i) == '(') {&#10;                depth++;&#10;            } else if (s.charAt(i) == ')') {&#10;                depth--;&#10;                if (depth == 0 &amp;&amp; i &lt; end) {&#10;                    return false;&#10;                }&#10;            }&#10;        }&#10;&#10;        return depth == 0;&#10;    }&#10;&#10;    /**&#10;     * Проверяет корректность расстановки скобок в строке.&#10;     *&#10;     * @param s строка для проверки&#10;     * @return true, если скобки расставлены корректно&#10;     */&#10;    private static boolean isValidParentheses(String s) {&#10;        int count = 0;&#10;        for (char c : s.toCharArray()) {&#10;            if (c == '(') {&#10;                count++;&#10;            }&#10;            if (c == ')') {&#10;                count--;&#10;            }&#10;            if (count &lt; 0) {&#10;                return false;&#10;            }&#10;        }&#10;        return count == 0;&#10;    }&#10;&#10;    private static boolean isValidVariable(String s) {&#10;        if (s.isEmpty()) {&#10;            return false;&#10;        }&#10;        if (!Character.isLetter(s.charAt(0))) {&#10;            return false;&#10;        }&#10;        for (char c : s.toCharArray()) {&#10;            if (!Character.isLetterOrDigit(c)) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Парсит строку с присваиваниями переменных.&#10;     *&#10;     * @param assignments строка вида &quot;x = 10; y = 13&quot;&#10;     * @return карта переменных и их значений&#10;     * @throws IllegalArgumentException если формат присваиваний некоррект��н&#10;     */&#10;    public static Map&lt;String, Integer&gt; parseAssignments(String assignments) {&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;&#10;        if (assignments == null || assignments.trim().isEmpty()) {&#10;            return vars;&#10;        }&#10;&#10;        String[] pairs = assignments.split(&quot;;&quot;);&#10;        for (String pair : pairs) {&#10;            pair = pair.trim();&#10;            if (pair.isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            String[] kv = pair.split(&quot;=&quot;);&#10;            if (kv.length != 2) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректный формат присваивания: '&quot; + pair&#10;                        + &quot;'. Ожидается формат 'переменная = значение'&quot;);&#10;            }&#10;&#10;            String varName = kv[0].trim();&#10;            String valueStr = kv[1].trim();&#10;&#10;            if (!isValidVariable(varName)) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректное имя переменной: '&quot; + varName&#10;                        + &quot;'. Переменная должна начинаться с буквы и содержать только &quot;&#10;                        + &quot;буквы и цифры&quot;);&#10;            }&#10;&#10;            try {&#10;                int value = Integer.parseInt(valueStr);&#10;                vars.put(varName, value);&#10;            } catch (NumberFormatException e) {&#10;                throw new IllegalArgumentException(&#10;                        &quot;Некорректное значение переменной: '&quot; + valueStr&#10;                        + &quot;'. Ожидается целое число&quot;);&#10;            }&#10;        }&#10;&#10;        return vars;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/ru/nsu/dashkovskii/Variable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/ru/nsu/dashkovskii/Variable.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.Map;&#10;import java.util.Set;&#10;import java.util.HashSet;&#10;&#10;/**&#10; * Класс, представляющий переменную в математическом выражении.&#10; */&#10;public class Variable extends Expression {&#10;    private final String name;&#10;&#10;    public Variable(String name) {&#10;        this.name = name;&#10;    }&#10;&#10;    @Override&#10;    public int evaluate(Map&lt;String, Integer&gt; variables) {&#10;        if (!variables.containsKey(name)) {&#10;            throw new IllegalArgumentException(&quot;Нет значения для переменной &quot; + name);&#10;        }&#10;        return variables.get(name);&#10;    }&#10;&#10;    @Override&#10;    public Expression derivative(String var) {&#10;        if (name.equals(var)) {&#10;            return new Number(1);&#10;        } else {&#10;            return new Number(0);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getVariables() {&#10;        Set&lt;String&gt; vars = new HashSet&lt;&gt;();&#10;        vars.add(name);&#10;        return vars;&#10;    }&#10;&#10;    @Override&#10;    protected Expression simplifyInternal() {&#10;        return this; // Переменные не упрощаются&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashSet;&#10;import java.util.Map;&#10;import java.util.Set;&#10;&#10;/**&#10; * Класс, представляющий переменную в математическом выражении.&#10; */&#10;public class Variable extends Expression {&#10;    private final String name;&#10;&#10;    public Variable(String name) {&#10;        this.name = name;&#10;    }&#10;&#10;    @Override&#10;    public int evaluate(Map&lt;String, Integer&gt; variables) {&#10;        if (!variables.containsKey(name)) {&#10;            throw new IllegalArgumentException(&quot;Нет значения для переменной &quot; + name);&#10;        }&#10;        return variables.get(name);&#10;    }&#10;&#10;    @Override&#10;    public Expression derivative(String var) {&#10;        if (name.equals(var)) {&#10;            return new Number(1);&#10;        } else {&#10;            return new Number(0);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Set&lt;String&gt; getVariables() {&#10;        Set&lt;String&gt; vars = new HashSet&lt;&gt;();&#10;        vars.add(name);&#10;        return vars;&#10;    }&#10;&#10;    @Override&#10;    protected Expression simplifyInternal() {&#10;        return this; // Переменные не упрощаются&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return name;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ExpressionTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ExpressionTest.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности абстрактного класса Expression.&#10; */&#10;public class ExpressionTest {&#10;&#10;    /**&#10;     * Тестирует метод eval с одной переменной.&#10;     */&#10;    @Test&#10;    public void testEval() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Number(5));&#10;        assertEquals(15, expr.eval(&quot;x = 10&quot;));&#10;        assertEquals(7, expr.eval(&quot;x = 2&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с несколькими переменными.&#10;     */&#10;    @Test&#10;    public void testEvalMultipleVariables() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        assertEquals(15, expr.eval(&quot;x = 10; y = 5&quot;));&#10;        assertEquals(7, expr.eval(&quot;x = 3; y = 4&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с пустыми присваиваниями для константного выражения.&#10;     */&#10;    @Test&#10;    public void testEvalEmptyAssignments() {&#10;        Expression expr = new Number(42);&#10;        assertEquals(42, expr.eval(&quot;&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с null присваиваниями для константного выражения.&#10;     */&#10;    @Test&#10;    public void testEvalNullAssignments() {&#10;        Expression expr = new Number(42);&#10;        // Если Parser.parseAssignments(null) корректно обрабатывает null&#10;        assertDoesNotThrow(() -&gt; expr.eval(null));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод print, проверяет отсутствие исключений.&#10;     */&#10;    @Test&#10;    public void testPrint() {&#10;        Expression expr = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        assertDoesNotThrow(() -&gt; expr.print());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод isConstant.&#10;     */&#10;    @Test&#10;    public void testIsConstant() {&#10;        Expression constant = new Number(42);&#10;        assertTrue(constant.isConstant());&#10;&#10;        Expression variable = new Variable(&quot;x&quot;);&#10;        assertFalse(variable.isConstant());&#10;&#10;        Expression expression = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        assertFalse(expression.isConstant());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод isEqual.&#10;     */&#10;    @Test&#10;    public void testIsEqual() {&#10;        Expression expr1 = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        Expression expr2 = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        Expression expr3 = new Add(new Variable(&quot;x&quot;), new Number(3));&#10;&#10;        assertTrue(expr1.isEqual(expr2));&#10;        assertFalse(expr1.isEqual(expr3)); // Порядок операндов важен&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод simplify.&#10;     */&#10;    @Test&#10;    public void testSimplify() {&#10;        // Тест упрощения x + 0 = x&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified = expr.simplify();&#10;        assertEquals(&quot;x&quot;, simplified.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод getVariables.&#10;     */&#10;    @Test&#10;    public void testGetVariables() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        assertEquals(2, expr.getVariables().size());&#10;        assertTrue(expr.getVariables().contains(&quot;x&quot;));&#10;        assertTrue(expr.getVariables().contains(&quot;y&quot;));&#10;&#10;        Expression constant = new Number(42);&#10;        assertTrue(constant.getVariables().isEmpty());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;import static org.junit.jupiter.api.Assertions.assertFalse;&#10;import static org.junit.jupiter.api.Assertions.assertTrue;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности абстрактного класса Expression.&#10; */&#10;public class ExpressionTest {&#10;&#10;    /**&#10;     * Тестирует метод eval с одной переменной.&#10;     */&#10;    @Test&#10;    public void testEval() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Number(5));&#10;        assertEquals(15, expr.eval(&quot;x = 10&quot;));&#10;        assertEquals(7, expr.eval(&quot;x = 2&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с несколькими переменными.&#10;     */&#10;    @Test&#10;    public void testEvalMultipleVariables() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        assertEquals(15, expr.eval(&quot;x = 10; y = 5&quot;));&#10;        assertEquals(7, expr.eval(&quot;x = 3; y = 4&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с пустыми присваиваниями для константного выражения.&#10;     */&#10;    @Test&#10;    public void testEvalEmptyAssignments() {&#10;        Expression expr = new Number(42);&#10;        assertEquals(42, expr.eval(&quot;&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод eval с null присваиваниями для константного выражения.&#10;     */&#10;    @Test&#10;    public void testEvalNullAssignments() {&#10;        Expression expr = new Number(42);&#10;        // Если Parser.parseAssignments(null) корректно обрабатывает null&#10;        assertDoesNotThrow(() -&gt; expr.eval(null));&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод print, проверяет отсутствие исключений.&#10;     */&#10;    @Test&#10;    public void testPrint() {&#10;        Expression expr = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        assertDoesNotThrow(() -&gt; expr.print());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод isConstant.&#10;     */&#10;    @Test&#10;    public void testIsConstant() {&#10;        Expression constant = new Number(42);&#10;        assertTrue(constant.isConstant());&#10;&#10;        Expression variable = new Variable(&quot;x&quot;);&#10;        assertFalse(variable.isConstant());&#10;&#10;        Expression expression = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        assertFalse(expression.isConstant());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод isEqual.&#10;     */&#10;    @Test&#10;    public void testIsEqual() {&#10;        Expression expr1 = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        Expression expr2 = new Add(new Number(3), new Variable(&quot;x&quot;));&#10;        Expression expr3 = new Add(new Variable(&quot;x&quot;), new Number(3));&#10;&#10;        assertTrue(expr1.isEqual(expr2));&#10;        assertFalse(expr1.isEqual(expr3)); // Порядок операндов важен&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод simplify.&#10;     */&#10;    @Test&#10;    public void testSimplify() {&#10;        // Тест упрощения x + 0 = x&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified = expr.simplify();&#10;        assertEquals(&quot;x&quot;, simplified.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует метод getVariables.&#10;     */&#10;    @Test&#10;    public void testGetVariables() {&#10;        Expression expr = new Add(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        assertEquals(2, expr.getVariables().size());&#10;        assertTrue(expr.getVariables().contains(&quot;x&quot;));&#10;        assertTrue(expr.getVariables().contains(&quot;y&quot;));&#10;&#10;        Expression constant = new Number(42);&#10;        assertTrue(constant.getVariables().isEmpty());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/MulTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/MulTest.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Mul.&#10; */&#10;public class MulTest {&#10;&#10;    /**&#10;     * Тестирует умножение двух числовых констант.&#10;     */&#10;    @Test&#10;    public void testEvaluateNumbers() {&#10;        Mul mul = new Mul(new Number(3), new Number(4));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(12, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение переменной на числовую константу.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithVariables() {&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Number(5));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 6);&#10;        assertEquals(30, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение двух переменных.&#10;     */&#10;    @Test&#10;    public void testEvaluateTwoVariables() {&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 7);&#10;        vars.put(&quot;y&quot;, 3);&#10;        assertEquals(21, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение на ноль.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithZero() {&#10;        Mul mul = new Mul(new Number(0), new Variable(&quot;x&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 10);&#10;        assertEquals(0, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной произведения (правило произведения).&#10;     */&#10;    @Test&#10;    public void testDerivativeProductRule() {&#10;        // d/dx(x * 3) = 1 * 3 + x * 0 = 3&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Number(3));&#10;        Expression derivative = mul.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        assertEquals(3, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной произведения двух переменных.&#10;     */&#10;    @Test&#10;    public void testDerivativeTwoVariables() {&#10;        // d/dx(x * y) = 1 * y + x * 0 = y&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Expression derivative = mul.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        vars.put(&quot;y&quot;, 7);&#10;        assertEquals(7, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует упрощение умножения.&#10;     */&#10;    @Test&#10;    public void testSimplification() {&#10;        // Умножение на 0 должно упрощаться до 0&#10;        Mul mul1 = new Mul(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified1 = mul1.simplify();&#10;        assertEquals(&quot;0&quot;, simplified1.toString());&#10;&#10;        // Умножение на 1 должно упрощаться до переменной&#10;        Mul mul2 = new Mul(new Variable(&quot;x&quot;), new Number(1));&#10;        Expression simplified2 = mul2.simplify();&#10;        assertEquals(&quot;x&quot;, simplified2.toString());&#10;&#10;        // Умножение констант должно вычисляться&#10;        Mul mul3 = new Mul(new Number(2), new Number(3));&#10;        Expression simplified3 = mul3.simplify();&#10;        assertEquals(&quot;6&quot;, simplified3.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует строковое представление операции умножения.&#10;     */&#10;    @Test&#10;    public void testToString() {&#10;        Mul mul = new Mul(new Number(2), new Variable(&quot;x&quot;));&#10;        assertEquals(&quot;(2*x)&quot;, mul.toString());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Mul.&#10; */&#10;public class MulTest {&#10;&#10;    /**&#10;     * Тестирует умножение двух числовых констант.&#10;     */&#10;    @Test&#10;    public void testEvaluateNumbers() {&#10;        Mul mul = new Mul(new Number(3), new Number(4));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(12, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение переменной на числовую константу.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithVariables() {&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Number(5));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 6);&#10;        assertEquals(30, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение двух переменных.&#10;     */&#10;    @Test&#10;    public void testEvaluateTwoVariables() {&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 7);&#10;        vars.put(&quot;y&quot;, 3);&#10;        assertEquals(21, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует умножение на ноль.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithZero() {&#10;        Mul mul = new Mul(new Number(0), new Variable(&quot;x&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 10);&#10;        assertEquals(0, mul.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной произведения (правило произведения).&#10;     */&#10;    @Test&#10;    public void testDerivativeProductRule() {&#10;        // d/dx(x * 3) = 1 * 3 + x * 0 = 3&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Number(3));&#10;        Expression derivative = mul.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        assertEquals(3, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной произведения двух переменных.&#10;     */&#10;    @Test&#10;    public void testDerivativeTwoVariables() {&#10;        // d/dx(x * y) = 1 * y + x * 0 = y&#10;        Mul mul = new Mul(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Expression derivative = mul.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        vars.put(&quot;y&quot;, 7);&#10;        assertEquals(7, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует упрощение умножения.&#10;     */&#10;    @Test&#10;    public void testSimplification() {&#10;        // Умножение на 0 должно упрощаться до 0&#10;        Mul mul1 = new Mul(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified1 = mul1.simplify();&#10;        assertEquals(&quot;0&quot;, simplified1.toString());&#10;&#10;        // Умножение на 1 должно упрощаться до переменной&#10;        Mul mul2 = new Mul(new Variable(&quot;x&quot;), new Number(1));&#10;        Expression simplified2 = mul2.simplify();&#10;        assertEquals(&quot;x&quot;, simplified2.toString());&#10;&#10;        // Умножение констант должно вычисляться&#10;        Mul mul3 = new Mul(new Number(2), new Number(3));&#10;        Expression simplified3 = mul3.simplify();&#10;        assertEquals(&quot;6&quot;, simplified3.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует строковое представление операции умножения.&#10;     */&#10;    @Test&#10;    public void testToString() {&#10;        Mul mul = new Mul(new Number(2), new Variable(&quot;x&quot;));&#10;        assertEquals(&quot;(2*x)&quot;, mul.toString());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ParserTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ParserTest.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.Map;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;import static org.junit.jupiter.api.Assertions.assertThrows;&#10;import static org.junit.jupiter.api.Assertions.assertTrue;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Parser.&#10; */&#10;public class ParserTest {&#10;&#10;    /**&#10;     * Тестирует парсинг числовой константы.&#10;     */&#10;    @Test&#10;    public void testParseNumber() {&#10;        Expression expr = Parser.parse(&quot;42&quot;);&#10;        assertEquals(&quot;42&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг переменной.&#10;     */&#10;    @Test&#10;    public void testParseVariable() {&#10;        Expression expr = Parser.parse(&quot;x&quot;);&#10;        assertEquals(&quot;x&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции сложения.&#10;     */&#10;    @Test&#10;    public void testParseAddition() {&#10;        Expression expr = Parser.parse(&quot;(3+x)&quot;);&#10;        assertEquals(&quot;(3+x)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции вычитания.&#10;     */&#10;    @Test&#10;    public void testParseSubtraction() {&#10;        Expression expr = Parser.parse(&quot;(x-5)&quot;);&#10;        assertEquals(&quot;(x-5)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции умножения.&#10;     */&#10;    @Test&#10;    public void testParseMultiplication() {&#10;        Expression expr = Parser.parse(&quot;(2*x)&quot;);&#10;        assertEquals(&quot;(2*x)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции деления.&#10;     */&#10;    @Test&#10;    public void testParseDivision() {&#10;        Expression expr = Parser.parse(&quot;(x/3)&quot;);&#10;        assertEquals(&quot;(x/3)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг вложенного выражения.&#10;     */&#10;    @Test&#10;    public void testParseNestedExpression() {&#10;        Expression expr = Parser.parse(&quot;((x+1)*(y-2))&quot;);&#10;        assertEquals(&quot;((x+1)*(y-2))&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг пустой строки, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseEmptyString() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг некорректных скобок, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseInvalidParentheses() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(x+&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;x+)&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;((x+y)&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг некорректного выражения, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseInvalidExpression() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;asdasd!@#&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;123abc&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг выражения с отсутствующим операндом.&#10;     */&#10;    @Test&#10;    public void testParseMissingOperand() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(+x)&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(x+)&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг корректных присваиваний переменных.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsValid() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;x = 10; y = 5&quot;);&#10;        assertEquals(2, vars.size());&#10;        assertEquals(10, vars.get(&quot;x&quot;));&#10;        assertEquals(5, vars.get(&quot;y&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг пустых присваиваний.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsEmpty() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;&quot;);&#10;        assertTrue(vars.isEmpty());&#10;&#10;        vars = Parser.parseAssignments(null);&#10;        assertTrue(vars.isEmpty());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг одного присваивания.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsSingle() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;x = 42&quot;);&#10;        assertEquals(1, vars.size());&#10;        assertEquals(42, vars.get(&quot;x&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным форматом.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidFormat() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = = 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным именем переменной.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidVariable() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;123 = 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x! = 10&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным значением переменной.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidValue() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = abc&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = 10.5&quot;));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.Map;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;import static org.junit.jupiter.api.Assertions.assertThrows;&#10;import static org.junit.jupiter.api.Assertions.assertTrue;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Parser.&#10; */&#10;public class ParserTest {&#10;&#10;    /**&#10;     * Тестирует парсинг числовой константы.&#10;     */&#10;    @Test&#10;    public void testParseNumber() {&#10;        Expression expr = Parser.parse(&quot;42&quot;);&#10;        assertEquals(&quot;42&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг переменной.&#10;     */&#10;    @Test&#10;    public void testParseVariable() {&#10;        Expression expr = Parser.parse(&quot;x&quot;);&#10;        assertEquals(&quot;x&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции сложения.&#10;     */&#10;    @Test&#10;    public void testParseAddition() {&#10;        Expression expr = Parser.parse(&quot;(3+x)&quot;);&#10;        assertEquals(&quot;(3+x)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции вычитания.&#10;     */&#10;    @Test&#10;    public void testParseSubtraction() {&#10;        Expression expr = Parser.parse(&quot;(x-5)&quot;);&#10;        assertEquals(&quot;(x-5)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции умножения.&#10;     */&#10;    @Test&#10;    public void testParseMultiplication() {&#10;        Expression expr = Parser.parse(&quot;(2*x)&quot;);&#10;        assertEquals(&quot;(2*x)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг операции деления.&#10;     */&#10;    @Test&#10;    public void testParseDivision() {&#10;        Expression expr = Parser.parse(&quot;(x/3)&quot;);&#10;        assertEquals(&quot;(x/3)&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестиру��т парсинг вложенного выражения.&#10;     */&#10;    @Test&#10;    public void testParseNestedExpression() {&#10;        Expression expr = Parser.parse(&quot;((x+1)*(y-2))&quot;);&#10;        assertEquals(&quot;((x+1)*(y-2))&quot;, expr.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг пустой строки, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseEmptyString() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг некорректных скобок, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseInvalidParentheses() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(x+&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;x+)&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;((x+y)&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг некорректного выражения, должен выбрасывать исключение.&#10;     */&#10;    @Test&#10;    public void testParseInvalidExpression() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;asdasd!@#&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;123abc&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг выражения с отсутствующим операндом.&#10;     */&#10;    @Test&#10;    public void testParseMissingOperand() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(+x)&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parse(&quot;(x+)&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг корректных присваиваний переменных.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsValid() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;x = 10; y = 5&quot;);&#10;        assertEquals(2, vars.size());&#10;        assertEquals(10, vars.get(&quot;x&quot;));&#10;        assertEquals(5, vars.get(&quot;y&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг пустых присваиваний.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsEmpty() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;&quot;);&#10;        assertTrue(vars.isEmpty());&#10;&#10;        vars = Parser.parseAssignments(null);&#10;        assertTrue(vars.isEmpty());&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг одного присваивания.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsSingle() {&#10;        Map&lt;String, Integer&gt; vars = Parser.parseAssignments(&quot;x = 42&quot;);&#10;        assertEquals(1, vars.size());&#10;        assertEquals(42, vars.get(&quot;x&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным форматом.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidFormat() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = = 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным именем переменной.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidVariable() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;123 = 10&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x! = 10&quot;));&#10;    }&#10;&#10;    /**&#10;     * Тестирует парсинг присваиваний с некорректным значением переменной.&#10;     */&#10;    @Test&#10;    public void testParseAssignmentsInvalidValue() {&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = abc&quot;));&#10;        assertThrows(IllegalArgumentException.class, () -&gt; Parser.parseAssignments(&quot;x = 10.5&quot;));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ScanTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/ScanTest.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Scan.&#10; */&#10;public class ScanTest {&#10;&#10;    /**&#10;     * Тестирует приватный метод isValidVariable с помощью рефлексии.&#10;     */&#10;    @Test&#10;    public void testIsValidVariableName() {&#10;        Scan scanner = new Scan();&#10;&#10;        try {&#10;            java.lang.reflect.Method method = Scan.class&#10;                    .getDeclaredMethod(&quot;isValidVariable&quot;, String.class);&#10;            method.setAccessible(true);&#10;&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;x&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;foo&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;var123&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;myVariable&quot;));&#10;&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;123&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;123abc&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;var!&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;my-var&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;my var&quot;));&#10;&#10;        } catch (Exception e) {&#10;            fail(&quot;Ошибка при тестировании isValidVariable: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Тестирует создание экземпляра Scan.&#10;     */&#10;    @Test&#10;    public void testScannerCreation() {&#10;        Scan scanner = new Scan();&#10;        assertNotNull(scanner);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertFalse;&#10;import static org.junit.jupiter.api.Assertions.assertNotNull;&#10;import static org.junit.jupiter.api.Assertions.assertTrue;&#10;import static org.junit.jupiter.api.Assertions.fail;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Scan.&#10; */&#10;public class ScanTest {&#10;&#10;    /**&#10;     * Тестиру��т приватный метод isValidVariable с помощью рефлексии.&#10;     */&#10;    @Test&#10;    public void testIsValidVariableName() {&#10;        Scan scanner = new Scan();&#10;&#10;        try {&#10;            java.lang.reflect.Method method = Scan.class&#10;                    .getDeclaredMethod(&quot;isValidVariable&quot;, String.class);&#10;            method.setAccessible(true);&#10;&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;x&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;foo&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;var123&quot;));&#10;            assertTrue((Boolean) method.invoke(scanner, &quot;myVariable&quot;));&#10;&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;123&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;123abc&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;var!&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;my-var&quot;));&#10;            assertFalse((Boolean) method.invoke(scanner, &quot;my var&quot;));&#10;&#10;        } catch (Exception e) {&#10;            fail(&quot;Ошибка при тестировании isValidVariable: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Тестирует создание экземпляра Scan.&#10;     */&#10;    @Test&#10;    public void testScannerCreation() {&#10;        Scan scanner = new Scan();&#10;        assertNotNull(scanner);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/SubTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/ru/nsu/dashkovskii/SubTest.java" />
              <option name="originalContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Sub.&#10; */&#10;public class SubTest {&#10;&#10;    /**&#10;     * Тестирует вычитание двух числовых констант.&#10;     */&#10;    @Test&#10;    public void testEvaluateNumbers() {&#10;        Sub sub = new Sub(new Number(10), new Number(3));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует вычитание числовой константы из переменной.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithVariables() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(5));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 12);&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует вычитание двух переменных.&#10;     */&#10;    @Test&#10;    public void testEvaluateTwoVariables() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 15);&#10;        vars.put(&quot;y&quot;, 8);&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестиру��т вычитание с отрицательным результатом.&#10;     */&#10;    @Test&#10;    public void testEvaluateNegativeResult() {&#10;        Sub sub = new Sub(new Number(3), new Number(10));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(-7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной от разности.&#10;     */&#10;    @Test&#10;    public void testDerivative() {&#10;        // d/dx(x - 5) = 1 - 0 = 1&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(5));&#10;        Expression derivative = sub.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 10);&#10;        assertEquals(1, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной от разности двух переменных.&#10;     */&#10;    @Test&#10;    public void testDerivativeTwoVariables() {&#10;        // d/dx(x - y) = 1 - 0 = 1&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Expression derivative = sub.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        vars.put(&quot;y&quot;, 3);&#10;        assertEquals(1, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует упрощение вычитания.&#10;     */&#10;    @Test&#10;    public void testSimplification() {&#10;        // Вычитание 0 должно упрощаться до левого операнда&#10;        Sub sub1 = new Sub(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified1 = sub1.simplify();&#10;        assertEquals(&quot;x&quot;, simplified1.toString());&#10;&#10;        // x - x должно упрощаться до 0&#10;        Sub sub2 = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;x&quot;));&#10;        Expression simplified2 = sub2.simplify();&#10;        assertEquals(&quot;0&quot;, simplified2.toString());&#10;&#10;        // Вычитание констант должно вычисляться&#10;        Sub sub3 = new Sub(new Number(10), new Number(3));&#10;        Expression simplified3 = sub3.simplify();&#10;        assertEquals(&quot;7&quot;, simplified3.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует строковое представление операции вычитания.&#10;     */&#10;    @Test&#10;    public void testToString() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(3));&#10;        assertEquals(&quot;(x-3)&quot;, sub.toString());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ru.nsu.dashkovskii;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.junit.jupiter.api.Test;&#10;&#10;import static org.junit.jupiter.api.Assertions.assertEquals;&#10;&#10;/**&#10; * Тестовый класс для проверки функциональности класса Sub.&#10; */&#10;public class SubTest {&#10;&#10;    /**&#10;     * Тестирует вычитание двух числовых констант.&#10;     */&#10;    @Test&#10;    public void testEvaluateNumbers() {&#10;        Sub sub = new Sub(new Number(10), new Number(3));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует вычитание числовой константы из переменной.&#10;     */&#10;    @Test&#10;    public void testEvaluateWithVariables() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(5));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 12);&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует вычитание двух переменных.&#10;     */&#10;    @Test&#10;    public void testEvaluateTwoVariables() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 15);&#10;        vars.put(&quot;y&quot;, 8);&#10;        assertEquals(7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестиру��т вычитание с отрицательным результатом.&#10;     */&#10;    @Test&#10;    public void testEvaluateNegativeResult() {&#10;        Sub sub = new Sub(new Number(3), new Number(10));&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        assertEquals(-7, sub.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной от разности.&#10;     */&#10;    @Test&#10;    public void testDerivative() {&#10;        // d/dx(x - 5) = 1 - 0 = 1&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(5));&#10;        Expression derivative = sub.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 10);&#10;        assertEquals(1, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует взятие производной от разности двух переменных.&#10;     */&#10;    @Test&#10;    public void testDerivativeTwoVariables() {&#10;        // d/dx(x - y) = 1 - 0 = 1&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;y&quot;));&#10;        Expression derivative = sub.derivative(&quot;x&quot;);&#10;&#10;        Map&lt;String, Integer&gt; vars = new HashMap&lt;&gt;();&#10;        vars.put(&quot;x&quot;, 5);&#10;        vars.put(&quot;y&quot;, 3);&#10;        assertEquals(1, derivative.evaluate(vars));&#10;    }&#10;&#10;    /**&#10;     * Тестирует упрощение вычитания.&#10;     */&#10;    @Test&#10;    public void testSimplification() {&#10;        // Вычитание 0 должно упрощаться до левого операнда&#10;        Sub sub1 = new Sub(new Variable(&quot;x&quot;), new Number(0));&#10;        Expression simplified1 = sub1.simplify();&#10;        assertEquals(&quot;x&quot;, simplified1.toString());&#10;&#10;        // x - x должно упрощаться до 0&#10;        Sub sub2 = new Sub(new Variable(&quot;x&quot;), new Variable(&quot;x&quot;));&#10;        Expression simplified2 = sub2.simplify();&#10;        assertEquals(&quot;0&quot;, simplified2.toString());&#10;&#10;        // Вычитание констант должно вычисляться&#10;        Sub sub3 = new Sub(new Number(10), new Number(3));&#10;        Expression simplified3 = sub3.simplify();&#10;        assertEquals(&quot;7&quot;, simplified3.toString());&#10;    }&#10;&#10;    /**&#10;     * Тестирует строковое представление операции вычитания.&#10;     */&#10;    @Test&#10;    public void testToString() {&#10;        Sub sub = new Sub(new Variable(&quot;x&quot;), new Number(3));&#10;        assertEquals(&quot;(x-3)&quot;, sub.toString());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>